---
title: Stack in Data Structures
description: Introduction to Stack in Data Structures. 
---

## Introduction to Stack in Data Structures
It has been a while since we started this DSA course. We saw array ADT, linked lists and their variants, their implementation, and their operations. From this tutorial on, we will start learning about stack data structures.

**Introduction:**

A stack is a linear data structure. Any operation on the stack is performed in LIFO (Last In First Out) order. This means the element to enter the container last would be the first one to leave the container. It is imperative that elements above an element in a stack must be removed first before fetching any element.

An element can be pushed in this basket-type container illustrated below. Any basket has a limit, and so does our container too. Elements in a stack can only be pushed to a limit. And this extra pushing of elements in a stack leads to stack overflow.

<AdaptiveThemeImage
  src={{
    dark: "/images/30.svg",
    light: "/images/30.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={570}
  height={400}
  alt="example"
/>

**Applications of Stack:**

- We have talked about function calls before as well. A function until it returns reserves a space in the memory stack. Any function embedded in some function comes above the parent function in the stack. So, first, the embedded function ends, and then the parent one. Here, the function called last ends first.  (LIFO).
- Infix to postfix conversion (and other similar conversions) will be dealt with in the coming tutorials.
- Parenthesis matching and many more...

**Stack ADT:**
In order to create a stack, we need a pointer to the topmost element to gain knowledge about the element which is on the top so that any operation can be carried about. Along with that, we need the space for the other elements to get in and their data.

Here are some of the basic operations we would want to perform on stacks:

1. push( ): to push an element into the stack
2. pop( ): to remove the topmost element from the stack

<AdaptiveThemeImage
  src={{
    dark: "/images/31.svg",
    light: "/images/31.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={570}
  height={400}
  alt="example"
/>

3. peek(index): to return the value at a given index

4. isempty() / isfull() : to determine whether the stack is empty or full to carry efficient push and pull operations.

**Implementation:**

A stack element can be implemented by both an array and a linked list. We’ll see both these methods in the coming tutorials.

> A stack is a collection of elements with certain operations following the LIFO (Last in First Out) discipline. If you are dealing with stacks, you should not forget about this. So, we’ll consider everything about stacks from the basics. Just stay.

## Implementing Stack Using Array in Data Structures
In the last tutorial, we learned about the stack data structure and its applications in several programming phases. We also discussed some of the operations possible on a stack. Today, we’ll try to implement these ideas on a stack using arrays. Although we have another choice of linked lists.

If you remember, a stack is a collection of elements following LIFO(Last In First Out); the element that gets pushed the last is the first one to come out of the stack.

### Stack Using an Array
If we recall, arrays are linear data structures whose elements are indexed, and the elements can be accessed in constant time with their index. To implement a stack using an array, we’ll maintain a variable that will store the index of the top element.

<AdaptiveThemeImage
  src={{
    dark: "/images/32.svg",
    light: "/images/32.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={570}
  height={400}
  alt="example"
/>

So, basically, we have few things to keep in check when we implement stacks using arrays.

1. **A fixed-size array**. This size can even be bigger than the size of the stack we are trying to implement, to stay on the safe side.

2. **An integer variable to store the index of the top element**, or the last element we entered in the array. This value is -1 when there is no element in the array.

> We will try constructing a structure to embed all these functionalities. Let’s see how.

```C
struct stack{
    int size;
    int top;
    int* arr;
}
```

So, the struct above includes as its members, the size of the array, the index of the top element, and the pointer to the array we will make.

To use this struct,

1. You will just have to declare a struct stack
2. Set its top element to -1. 
3. Furthermore, you will have to reserve memory in the heap using malloc.

Follow the example below for defining a stack:

```C
    struct stack S;
    S.size = 80;
    S.top = -1;
    S.arr = (int*)malloc(S.size*sizeof(int));
```


We have used an integer array above, although it is just for the sake of simplicity. You have the freedom to customize your data types according to your needs.

We can now move on implementing the stack ADT, particularly their operators. We have in the list, push and pull, peek, and isempty/full operation. Let’s visit them one by one.

**push( ):**

By pushing, we mean inserting an element at the top of the stack. While using the arrays, we have the index to the top element of the array. So, we’ll just insert the new element at the index (top+1) and increase the top by 1. This operation takes a constant time, O(1). It’s intuitive to note that this operation is valid until (top+1) is a valid index and the array has an empty space.

**pop( ):**

Pop means to remove the last element entered in the stack, and that element has the index top. So, this becomes an easy job. We’ll just have to decrease the value of the top by 1, and we are done. The popped element can even be used in any way we lik