---
title: Infix To Postfix Using Stack
description: Infix to Postfix using a Stack involves converting an infix expression to postfix by utilizing a stack to manage operators' precedence and associativity.
---

## Infix To Postfix Using Stack
In the last docs, we had learned to convert an infix expression to its postfix and prefix equivalents manually. Following were the simple steps we followed.

1. Parenthesize the expression following the operators’ precedence and their associativity.
2. From the innermost to outermost, keep converting the expressions.

But we didn’t talk about their implementation using stacks; rather, we didn’t even mention stacks in our last class. Today, we will learn how to convert an infix expression into its postfix equivalent using stacks.

Converting an infix expression to its postfix counterpart needs you to follow certain steps. The following are the steps:

1. Start moving left to right from the beginning of the expression.
2. The moment you receive an operand, concatenate it to the postfix expression string.
3. And the moment you encounter an operator, move to the stack along with its relative precedence number and see if the topmost operator in the stack has higher or lower precedence. If it's lower, push this operator inside the stack. Else, keep popping operators from the stack and concatenate it to the postfix expression until the topmost operator becomes weaker in precedence relative to the current operator.
4. If you reach the EOE, pop every element from the stack, and concatenate them as well. And the expression you will receive after doing all the steps will be the postfix equivalent of the expression we were given.

For our understanding today, let us consider the expression **x - y / z - k * a**. Step by step, we will turn this expression into its postfix equivalent using stacks.

### 1. We will start traversing from the left. 

<AdaptiveThemeImage
  src={{
    dark: "/images/56.svg",
    light: "/images/56.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

### 2. First, we got the letter ‘x’. We just pushed it into the postfix string. Then we got the subtraction symbol ‘-’, and we push it into the stack since the stack is empty.

<AdaptiveThemeImage
  src={{
    dark: "/images/57.svg",
    light: "/images/57.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

### 3. Similarly, we push the division operator in the stack since the topmost operator has a precedence number 1, and the division has 2.

<AdaptiveThemeImage
  src={{
    dark: "/images/58.svg",
    light: "/images/58.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

### 4. The next operator we encounter is again a subtraction. Since the topmost operator in the stack has an operator precedence number 2, we would pop elements out from the stack until we can push the current operator. This leads to removing both the present operators in the stack since they are both greater or equal in precedence. Don’t forget to concatenate the popped operators to the postfix expression.

<AdaptiveThemeImage
  src={{
    dark: "/images/59.svg",
    light: "/images/59.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

### 5. Next, we have a multiplication operator whose precedence number is 2 relative to the topmost operator in the stack. Hence we simply push it in the stack.

<AdaptiveThemeImage
  src={{
    dark: "/images/60.svg",
    light: "/images/60.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

### 6. And then we get to the EOE and still have two elements inside the stack. So, just pop them one by one, and concatenate them to the postfix. And this is when we succeed in converting the infix to the postfix expression.

<AdaptiveThemeImage
  src={{
    dark: "/images/61.svg",
    light: "/images/61.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

Follow every step meticulously, and you will find it very easy to master this. You can see if the answer we found at the end is correct manually.  

- x - y / z - k * a →  (( x - ( y / z )) - ( k * a )) →  (( x - [ y z / ]) - [ k a * ]  )  → [ x y z / - ] - [ k a * ]  →  x y z / - k a * -  

And it is indeed a correct conversion. I would now want you to follow the same steps and convert the expression x + y * z - k, using the stack method, and verify your answer manually using parentheses.

This was visualizing the conversion process of infix to postfix using stacks. We will see the programming part in the next tutorial. It would be best if you practiced converting a few expressions of your own. If you still feel diffident about using stacks, you must check out the previous docs where we discussed stacks in detail.

## Coding Infix to Postfix in C using Stack example & codes 
We saw earlier how infix expressions can be converted to their other equivalents manually. But when it came to automating the process, we took a different path. We used stacks to take hold of the operators we encountered in the expression. We followed an algorithm to convert an infix expression to its postfix equivalent, which in short, said:

1. We create a string variable that will hold our postfix expression. We start moving from the left to the right. And the moment we receive an operand, we concatenate it to the postfix string. And whenever we encounter an operator, we proceed with the following steps:

- Keep in account the operator and its relative precedence.
- If either the stack is empty or its topmost operator has lower relative precedence, push this operator-precedence pair inside the stack.
- Else, keep popping operators from the stack and concatenate it to the postfix expression until the topmost operator becomes weaker in precedence relative to the current operator.

2. If you reach the EOE, pop every element from the stack, if there is any, and concatenate them as well. And there, you’ll have your postfix expression.

Let us now see the program pursuing the conversion. I have attached the snippets alongwith. Keep checking them while you understand the codes.

**Understanding the program for infix to postfix conversion:**

1. First of all, create a character pointer function infixToPostfix since the function has to return a character array. And now pass into this function the given expression, which is also a character pointer.

2. Define a struct stack pointer variable sp. And give it the required memory in the heap. Create the instance. It’s safe to assume that a struct stack element and all its basic operations, push, pop, etc., have already been defined. You better copy everything from the stack tutorial.

3. Create a character array/pointer postfix, and assign it sufficient memory to hold all the characters of the infix expression in the heap.

4. Create two counters, one to traverse through the infix and another to traverse and insert in the postfix. Refer to the illustration below, which describes the initial conditions.

<AdaptiveThemeImage
  src={{
    dark: "/images/62.svg",
    light: "/images/62.svg",
  }}
  className="mx-auto pb-4 pt-0"
  width={770}
  height={450}
  alt="example"
/>

5. Run a while loop until we reach the EOE of the infix. And inside that loop, check if the current index holds an operator, and if it’s not, add that character into the postfix and increment both the counters by 1. And if it does hold an operator, call another function that would check if the precedence of the stackTop is less than the precedence of the current operator. If yes, push it inside the stack. Else, pop the stackTop, and add it back into the postfix. Increment j by 1.

```C
char* infixToPostfix(char* infix){
    struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
    sp->size = 10; 
    sp->top = -1;
    sp->arr = (char *) malloc(sp->size * sizeof(char));
    char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
    int i=0; // Track infix traversal
    int j = 0; // Track postfix addition 
    while (infix[i]!='\0')
    {
        if(!isOperator(infix[i])){
            postfix[j] = infix[i];
            j++;
            i++;
        }
        else{
            if(precedence(infix[i])> precedence(stackTop(sp))){
                push(sp, infix[i]);
                i++;
            }
            else{
                postfix[j] = pop(sp);
                j++;
            }
        }
    }
    while (!isEmpty(sp))    
    {
        postfix[j] = pop(sp);
        j++;
    }
    postfix[j] = '\0';
    return postfix;
}
```

> Code Snippet 1: Creating the function infixToPostfix

6. It’s now time to create the two functions to make this conversion possible. isOperator & precedence which checks if a character is an operator and compares the precedence of two operators respectively.

7. Create an integer function isOperator which takes a character as its parameter and returns 2, if it's an operator, and 0 otherwise.

```C
int isOperator(char ch){
    if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
        return 1;
    else
        return 0;
}
```

> Code Snippet 2: Creating the function isOperator

8. Create another integer function precedence, which takes a character as its parameter, and returns its relative precedence. It returns 3 if it’s a ‘/’ or a ‘*’. And 2 if it's a ‘+’ or a ‘-’.

9. If we are still left with any element in the stack at the end, pop them all and add them to the postfix.

```C
int precedence(char ch){
    if(ch == '*' || ch=='/')
        return 3;
    else if(ch == '+' || ch=='-')
        return 2; 
    else
        return 0;
}
```

Code Snippet 3: Creating the function precedence

And we have successfully finished writing the codes. 

Here is the whole source code:
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
struct stack
{
    int size;
    int top;
    char *arr;
};
 
int stackTop(struct stack* sp){
    return sp->arr[sp->top];
}
 
int isEmpty(struct stack *ptr)
{
    if (ptr->top == -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
int isFull(struct stack *ptr)
{
    if (ptr->top == ptr->size - 1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
void push(struct stack* ptr, char val){
    if(isFull(ptr)){
        printf("Stack Overflow! Cannot push %d to the stack\n", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top] = val;
    }
}
 
char pop(struct stack* ptr){
    if(isEmpty(ptr)){
        printf("Stack Underflow! Cannot pop from the stack\n");
        return -1;
    }
    else{
        char val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
    }
}
int precedence(char ch){
    if(ch == '*' || ch=='/')
        return 3;
    else if(ch == '+' || ch=='-')
        return 2; 
    else
        return 0;
}
 
int isOperator(char ch){
    if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
        return 1;
    else
        return 0;
}
char* infixToPostfix(char* infix){
    struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
    sp->size = 10; 
    sp->top = -1;
    sp->arr = (char *) malloc(sp->size * sizeof(char));
    char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
    int i=0; // Track infix traversal
    int j = 0; // Track postfix addition 
    while (infix[i]!='\0')
    {
        if(!isOperator(infix[i])){
            postfix[j] = infix[i];
            j++;
            i++;
        }
        else{
            if(precedence(infix[i])> precedence(stackTop(sp))){
                push(sp, infix[i]);
                i++;
            }
            else{
                postfix[j] = pop(sp);
                j++;
            }
        }
    }
    while (!isEmpty(sp))    
    {
        postfix[j] = pop(sp);
        j++;
    }
    postfix[j] = '\0';
    return postfix;
}
int main()
{
    char * infix = "x-y/z-k*d";
    printf("postfix is %s", infixToPostfix(infix));
    return 0;
}
```

> Code Snippet 4: Source code for the function infixToPostfix

We now need to check the function for some expressions to see if it works.

```C
    char * infix = "x-y/z-k*d";
    printf("postfix is %s", infixToPostfix(infix));
```

> Code Snippet 5: Calling the function infixToPostfix
```
postfix is xyz/-kd*-
PS D:\Code>
```

> Figure 1: Output of the above program

So, yes, we could automate the process of conversion through some codes. This must surely be easy for you after having a strong grip on the basics. If you missed any of these concepts, do mind checking them out. 

